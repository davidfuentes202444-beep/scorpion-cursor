<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Escorpión Gigante - Seguidor de Cursor</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: sans-serif; }
        #instrucciones { position: absolute; top: 10px; left: 10px; color: #555; pointer-events: none; }
    </style>
</head>
<body>
<div id="instrucciones">Mueve el mouse para guiar al escorpión...</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Luces
    const ambient = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambient);
    const pointLight = new THREE.PointLight(0xff3300, 1, 100);
    pointLight.position.set(0, 5, 5);
    scene.add(pointLight);

    // --- CONFIGURACIÓN ---
    const MOUSE = new THREE.Vector2();
    const NUM_SEGMENTOS = 25; // ¡Súper largo!
    const segmentos = [];
    const patas = [];

    // --- CREACIÓN DEL CUERPO (CADENA) ---
    for (let i = 0; i < NUM_SEGMENTOS; i++) {
        const size = i === 0 ? 1.5 : 1.2 - (i * 0.04); // Se adelgaza
        const geo = new THREE.BoxGeometry(size, size * 0.6, 1);
        const mat = new THREE.MeshStandardMaterial({ color: i === 0 ? 0x330000 : 0x111111 });
        const mesh = new THREE.Mesh(geo, mat);
        
        mesh.position.z = -i * 1.0;
        segmentos.push(mesh);
        scene.add(mesh);

        // Añadir patas solo en los segmentos frontales (estilo insecto)
        if (i > 1 && i < 6) {
            crearParPatas(mesh, i);
        }
    }

    function crearParPatas(segmento, indice) {
        [1, -1].forEach(lado => {
            const pataRaiz = new THREE.Group();
            
            // Fémur
            const femur = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.2, 0.2), new THREE.MeshStandardMaterial({color: 0x222222}));
            femur.position.set(0.6 * lado, 0, 0);
            femur.rotation.z = 1 * lado;
            
            // Tibia (Articulada)
            const tibia = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.5, 0.15), new THREE.MeshStandardMaterial({color: 0x050505}));
            tibia.position.y = -0.6;
            tibia.rotation.z = -0.8 * lado;
            
            femur.add(tibia);
            pataRaiz.add(femur);
            segmento.add(pataRaiz);
            patas.push({ raiz: pataRaiz, f: femur, t: tibia, lado, indice });
        });
    }

    camera.position.set(0, 15, 10);
    camera.lookAt(0, 0, 0);

    // --- EVENTO MOUSE ---
    window.addEventListener('mousemove', (e) => {
        MOUSE.x = (e.clientX / window.innerWidth) * 2 - 1;
        MOUSE.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    // --- LOOP DE ANIMACIÓN ---
    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.005;

        // 1. La cabeza sigue al cursor suavemente
        const targetX = MOUSE.x * 15;
        const targetZ = -MOUSE.y * 15;
        segmentos[0].position.x += (targetX - segmentos[0].position.x) * 0.05;
        segmentos[0].position.z += (targetZ - segmentos[0].position.z) * 0.05;
        
        // Rotación de la cabeza hacia el objetivo
        segmentos[0].lookAt(targetX, segmentos[0].position.y, targetZ);

        // 2. Cada segmento sigue al anterior (Efecto serpiente/escorpión largo)
        for (let i = 1; i < NUM_SEGMENTOS; i++) {
            const prev = segmentos[i-1];
            const curr = segmentos[i];
            
            const dx = prev.position.x - curr.position.x;
            const dz = prev.position.z - curr.position.z;
            const angle = Math.atan2(dx, dz);
            
            curr.rotation.y = angle;
            
            const dist = Math.sqrt(dx*dx + dz*dz);
            const minDist = 0.9;
            if (dist > minDist) {
                curr.position.x += Math.sin(angle) * (dist - minDist);
                curr.position.z += Math.cos(angle) * (dist - minDist);
            }
            // Ondulación sutil
            curr.position.y = Math.sin(time + i * 0.3) * 0.2;
        }

        // 3. Caminata articulada (Solo cuando se mueve)
        patas.forEach(p => {
            const vel = 0.05;
            const ciclo = time * 2 + (p.indice * 0.8) + (p.lado > 0 ? 0 : Math.PI);
            
            // Movimiento real de patas (no desliza)
            const levantamiento = Math.max(0, Math.sin(ciclo)) * 0.7;
            const avance = Math.cos(ciclo) * 0.5;
            
            p.f.rotation.x = avance; // Mueve hacia adelante
            p.t.rotation.x = -levantamiento; // Dobla la articulación "rodilla"
            p.raiz.position.y = levantamiento; // Levanta del suelo
        });

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
