// --- CONFIGURACIÓN DEL ESCORPIÓN ---
const SCORPION_CONFIG = {
    segmentosCuerpo: 10,        // EXTRA LARGO
    numPatas: 8,                // 4 pares
    longitudPata: 2.5,
    velocidadCaminata: 0.05
};

// --- CREACIÓN DEL CUERPO (Largo) ---
const grupoEscorpion = new THREE.Group();
const segmentos = [];

for (let i = 0; i < SCORPION_CONFIG.segmentosCuerpo; i++) {
    const geo = new THREE.BoxGeometry(1.2, 0.8, 1.5);
    const mat = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const seg = new THREE.Mesh(geo, mat);
    
    seg.position.z = -i * 1.3; // Posicionamiento longitudinal
    seg.scale.set(1 - i*0.05, 1 - i*0.05, 1); // Se hace más delgado hacia la cola
    
    segmentos.push(seg);
    grupoEscorpion.add(seg);
}

// --- CREACIÓN DE PATAS ARTICULADAS ---
const patas = [];

function crearPata(lado, indice) {
    const pataGrupo = new THREE.Group();
    
    // Articulación 1 (Femur)
    const femur = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 1.5),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    femur.rotation.z = Math.PI / 3 * lado;
    
    // Articulación 2 (Tibia/Pie)
    const tibia = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.02, 1.5),
        new THREE.MeshStandardMaterial({ color: 0x111111 })
    );
    tibia.position.y = -1.2;
    tibia.rotation.z = -Math.PI / 4 * lado;
    
    femur.add(tibia);
    pataGrupo.add(femur);
    
    // Posición en el cuerpo (distribuidas a lo largo)
    pataGrupo.position.set(0.8 * lado, 0, -indice * 1.2);
    return { malla: pataGrupo, lado, indice };
}

for (let i = 0; i < SCORPION_CONFIG.numPatas / 2; i++) {
    patas.push(crearPata(1, i + 1));  // Derecha
    patas.push(crearPata(-1, i + 1)); // Izquierda
}

patas.forEach(p => grupoEscorpion.add(p.malla));

// --- LÓGICA DE CAMINATA (SIN DESLIZAR) ---
function animarCaminata(tiempo) {
    patas.forEach((pata, i) => {
        // Desfase para que no muevan todas a la vez
        const desfase = (pata.lado > 0) ? (pata.indice * 0.5) : (pata.indice * 0.5 + Math.PI);
        const t = (tiempo * 5) + desfase;

        // Movimiento Vertical (Levantar la pata)
        const lift = Math.max(0, Math.sin(t)) * 0.8; 
        
        // Movimiento Horizontal (Avance)
        const stride = Math.cos(t) * 0.5;

        pata.malla.position.y = lift;
        pata.malla.position.z = (-pata.indice * 1.2) + stride;
        
        // Rotación de la articulación para realismo
        pata.malla.children[0].rotation.x = Math.sin(t) * 0.3;
    });

    // Movimiento ondulante del cuerpo (cola)
    segmentos.forEach((seg, i) => {
        seg.position.y = Math.sin(tiempo * 2 + i * 0.3) * 0.1;
        seg.rotation.y = Math.cos(tiempo * 2 + i * 0.3) * 0.05;
    });
}

// En el loop de renderizado:
// function animate() {
//    requestAnimationFrame(animate);
//    const time = Date.now() * 0.002;
//    animarCaminata(time);
//    renderer.render(scene, camera);
// }
